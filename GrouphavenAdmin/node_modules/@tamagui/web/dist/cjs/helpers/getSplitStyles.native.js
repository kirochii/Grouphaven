"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var getSplitStyles_exports = {};
__export(getSplitStyles_exports, {
  PROP_SPLIT: () => PROP_SPLIT,
  getSplitStyles: () => getSplitStyles,
  getSubStyle: () => getSubStyle,
  useSplitStyles: () => useSplitStyles
});
module.exports = __toCommonJS(getSplitStyles_exports);
var import_constants = require("@tamagui/constants"), import_helpers = require("@tamagui/helpers"), import_react = __toESM(require("react")), import_getDynamicVal = require("./getDynamicVal"), import_config = require("../config"), import_accessibilityDirectMap = require("../constants/accessibilityDirectMap"), import_constants2 = require("../constants/constants"), import_isDevTools = require("../constants/isDevTools"), import_useMedia = require("../hooks/useMedia"), import_consoleLog = require("./consoleLog"), import_createMediaStyle = require("./createMediaStyle"), import_expandStyles = require("./expandStyles"), import_getCSSStylesAtomic = require("./getCSSStylesAtomic"), import_getGroupPropParts = require("./getGroupPropParts"), import_insertStyleRule = require("./insertStyleRule"), import_isActivePlatform = require("./isActivePlatform"), import_isActiveTheme = require("./isActiveTheme"), import_log = require("./log"), import_normalizeValueWithProperty = require("./normalizeValueWithProperty"), import_propMapper = require("./propMapper"), import_pseudoDescriptors = require("./pseudoDescriptors"), import_skipProps = require("./skipProps"), import_sortString = require("./sortString"), import_transformsToString = require("./transformsToString"), conf, PROP_SPLIT = "-";
function isValidStyleKey(key, validStyles, accept) {
  return key in validStyles ? !0 : accept && key in accept;
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) {
  var _loop = function(keyOg2) {
    var keyInit = keyOg2, valInit = props[keyInit];
    if (keyInit === "children")
      return viewProps[keyInit] = valInit, "continue";
    if (process.env.NODE_ENV === "development" && debug === "profile" && time`before-prop-${keyInit}`, process.env.NODE_ENV === "test" && keyInit === "jestAnimatedStyle")
      return "continue";
    if (accept) {
      var accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && typeof valInit == "object")
        return viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps.noClass), "continue";
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_consoleLog.groupEnd)(), disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className" || keyInit in usedKeys) return "continue";
    if (keyInit in import_skipProps.skipProps && !noSkip && !isHOC) {
      if (keyInit === "group" && 0)
        var identifier2, containerType, containerCSS;
      return "continue";
    }
    var valInitType = typeof valInit, isValidStyleKeyInit = isValidStyleKey(keyInit, validStyles, accept);
    if (0 && staticConfig.isReactNative && keyInit.startsWith("data-"))
      var _viewProps2, _dataSet;
    if (!isValidStyleKeyInit) {
      if (!import_constants.isAndroid && keyInit === "elevationAndroid")
        return "continue";
      if (keyInit === "userSelect")
        keyInit = "selectable", valInit = valInit !== "none";
      else if (keyInit.startsWith("data-"))
        return "continue";
    }
    if (keyInit === "dataSet") {
      for (var keyInit1 in valInit)
        viewProps[`data-${hyphenate(keyInit1)}`] = valInit[keyInit1];
      return "continue";
    }
    if (0 && !noExpand)
      var didUseKeyInit;
    var isVariant = !isValidStyleKeyInit && variants && keyInit in variants, isStyleLikeKey = isValidStyleKeyInit || isVariant, isPseudo = keyInit in import_helpers.validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && (0, import_useMedia.isMediaKey)(keyInit), isMediaOrPseudo = !!(isMedia || isPseudo);
    if (isMediaOrPseudo && keyInit.startsWith("$group-")) {
      var parts = keyInit.split("-");
      if (
        // check if its actually a simple group selector to avoid breaking selectors
        parts.length === 2 || parts.length === 3 && import_pseudoDescriptors.pseudoPriorities[parts[parts.length - 1]]
      ) {
        var name2 = parts[1];
        context != null && context.groups.subscribe && !(context != null && context.groups.state[name2]) && (keyInit = keyInit.replace("$group-", "$group-true-"));
      }
    }
    var isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web"))
      return "continue";
    var shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentVariants == null ? void 0 : parentVariants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in import_skipProps.skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (process.env.NODE_ENV === "development" && debug === "verbose" && ((0, import_consoleLog.groupEnd)(), (0, import_consoleLog.groupEnd)(), (0, import_consoleLog.groupCollapsed)(`  \u{1F511} ${keyOg2}${keyInit !== keyOg2 ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""}`), (0, import_log.log)({
      isVariant,
      valInit,
      shouldPassProp
    }), import_constants.isClient && (0, import_log.log)({
      variants,
      variant: variants == null ? void 0 : variants[keyInit],
      isVariant,
      isHOCShouldPassThrough,
      parentStaticConfig
    })), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant) || !noSkip && keyInit in import_skipProps.skipProps)
      return "continue";
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
    var disablePropMap = isMediaOrPseudo || !isStyleLikeKey;
    if ((0, import_propMapper.propMapper)(keyInit, valInit, styleState, disablePropMap, function(key4, val2) {
      var _parentStaticConfig_variants, isStyledContextProp = styleProps.styledContextProps && key4 in styleProps.styledContextProps;
      if (!isHOC && disablePropMap && !isStyledContextProp && !isMediaOrPseudo) {
        viewProps[key4] = val2;
        return;
      }
      if (process.env.NODE_ENV === "development" && debug === "verbose" && ((0, import_consoleLog.groupCollapsed)("  \u{1F4A0} expanded", keyInit, "=>", key4), (0, import_log.log)(val2), (0, import_consoleLog.groupEnd)()), val2 != null && !(key4 in usedKeys)) {
        if (key4 === "pointerEvents") {
          viewProps[key4] = val2;
          return;
        }
        if (!isHOC && isValidStyleKey(key4, validStyles, accept) || import_constants.isAndroid && key4 === "elevation") {
          mergeStyle(styleState, key4, val2);
          return;
        }
        if (isPseudo = key4 in import_helpers.validPseudoKeys, isMedia = !isPseudo && (0, import_useMedia.isMediaKey)(key4), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key4 in variants, inlineProps != null && inlineProps.has(key4) || process.env.IS_STATIC === "is_static" && (inlineWhenUnflattened != null && inlineWhenUnflattened.has(key4))) {
          var _props_key;
          viewProps[key4] = (_props_key = props[key4]) !== null && _props_key !== void 0 ? _props_key : val2;
        }
        var shouldPassThrough2 = styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo || (parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit]));
        if (shouldPassThrough2) {
          passDownProp(viewProps, key4, val2, isMediaOrPseudo), process.env.NODE_ENV === "development" && debug === "verbose" && ((0, import_consoleLog.groupCollapsed)(` - passing down prop ${key4}`), (0, import_log.log)({
            val: val2,
            after: {
              ...viewProps[key4]
            }
          }), (0, import_consoleLog.groupEnd)());
          return;
        }
        if (isPseudo) {
          if (!val2) return;
          var pseudoStyleObject = getSubStyle(styleState, key4, val2, styleProps.noClass && process.env.IS_STATIC !== "is_static");
          if (!shouldDoClasses || process.env.IS_STATIC === "is_static") {
            var _pseudos, _key;
            if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key4] || (_pseudos[_key] = {}), process.env.IS_STATIC === "is_static") {
              Object.assign(pseudos[key4], pseudoStyleObject);
              return;
            }
          }
          var descriptor = import_pseudoDescriptors.pseudoDescriptors[key4], isEnter = key4 === "enterStyle", isExit = key4 === "exitStyle";
          if (!descriptor)
            return;
          if (shouldDoClasses && !isExit) {
            var pseudoStyles = (0, import_getCSSStylesAtomic.getStyleAtomic)(pseudoStyleObject, descriptor);
            process.env.NODE_ENV === "development" && debug === "verbose" && console.info("pseudo:", key4, pseudoStyleObject, pseudoStyles);
            var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
            try {
              for (var _iterator2 = pseudoStyles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                var psuedoStyle = _step2.value, fullKey = `${psuedoStyle[import_helpers.StyleObjectProperty]}${PROP_SPLIT}${descriptor.name}`;
                fullKey in usedKeys || (addStyleToInsertRules(rulesToInsert, psuedoStyle), classNames[fullKey] = psuedoStyle[import_helpers.StyleObjectIdentifier]);
              }
            } catch (err) {
              _didIteratorError2 = !0, _iteratorError2 = err;
            } finally {
              try {
                !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
              } finally {
                if (_didIteratorError2)
                  throw _iteratorError2;
              }
            }
          }
          if (!shouldDoClasses || isExit || isEnter) {
            var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled = componentState[descriptorKey] === !1;
            isExit && (isDisabled = !styleProps.isExiting), isEnter && componentState.unmounted === !1 && (isDisabled = !0), process.env.NODE_ENV === "development" && debug === "verbose" && ((0, import_consoleLog.groupCollapsed)("pseudo", key4, {
              isDisabled
            }), (0, import_log.log)({
              pseudoStyleObject,
              isDisabled,
              descriptor,
              componentState
            }), (0, import_consoleLog.groupEnd)());
            var importance = descriptor.priority;
            for (var pkey in pseudoStyleObject) {
              var _$val = pseudoStyleObject[pkey];
              if (isDisabled)
                applyDefaultStyle(pkey, styleState);
              else {
                var curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                if (shouldMerge) {
                  if (process.env.IS_STATIC === "is_static") {
                    var _pseudos1, _key1;
                    pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key4] || (_pseudos1[_key1] = {}), pseudos[key4][pkey] = _$val;
                  }
                  mergeStyle(styleState, pkey, _$val);
                }
                process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("    subKey", pkey, shouldMerge, {
                  importance,
                  curImportance,
                  pkey,
                  val: _$val
                });
              }
            }
            if (!isDisabled)
              for (var _$key in val2) {
                var k = shorthands[_$key] || _$key;
                usedKeys[k] = Math.max(importance, usedKeys[k] || 0);
              }
          }
          return;
        }
        if (isMedia) {
          if (!val2) return;
          var hasSpace = val2.space, mediaKeyShort = key4.slice(isMedia == "theme" ? 7 : 1);
          if (hasMedia || (hasMedia = !0), (hasSpace || !shouldDoClasses || styleProps.willBeAnimated) && ((!hasMedia || typeof hasMedia == "boolean") && (hasMedia = /* @__PURE__ */ new Set()), hasMedia.add(mediaKeyShort)), isMedia === "platform" && !(0, import_isActivePlatform.isActivePlatform)(key4))
            return;
          if (process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(`  \u{1F4FA} ${key4}`, {
            key: key4,
            val: val2,
            props,
            shouldDoClasses,
            acceptsClassName,
            componentState,
            mediaState
          }), shouldDoClasses) {
            var mediaStyle = getSubStyle(styleState, key4, val2, !1);
            if (hasSpace && (delete mediaStyle.space, mediaState[mediaKeyShort])) {
              var importance1 = (0, import_useMedia.getMediaImportanceIfMoreImportant)(mediaKeyShort, "space", usedKeys, !0);
              importance1 && (space = val2.space, usedKeys.space = importance1, process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(`Found more important space for current media ${mediaKeyShort}: ${val2} (importance: ${importance1})`));
            }
            var mediaStyles = (0, import_getCSSStylesAtomic.getCSSStylesAtomic)(mediaStyle), priority = mediaStylesSeen;
            mediaStylesSeen += 1;
            var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
            try {
              for (var _iterator12 = mediaStyles[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = !0) {
                var style3 = _step12.value, property = style3[import_helpers.StyleObjectProperty], isSubStyle = property[0] === "$";
                if (!(isSubStyle && !(0, import_isActivePlatform.isActivePlatform)(property))) {
                  var out = (0, import_createMediaStyle.createMediaStyle)(style3, mediaKeyShort, import_useMedia.mediaQueryConfig, isMedia, !1, priority);
                  process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("\u{1F4FA} media style:", out);
                  var subKey = isSubStyle ? style3[2] : "", fullKey1 = `${style3[import_helpers.StyleObjectProperty]}${subKey}${PROP_SPLIT}${mediaKeyShort}${style3[import_helpers.StyleObjectPseudo] || ""}`;
                  fullKey1 in usedKeys || (addStyleToInsertRules(rulesToInsert, out), classNames[fullKey1] = out[import_helpers.StyleObjectIdentifier]);
                }
              }
            } catch (err) {
              _didIteratorError12 = !0, _iteratorError12 = err;
            } finally {
              try {
                !_iteratorNormalCompletion12 && _iterator12.return != null && _iterator12.return();
              } finally {
                if (_didIteratorError12)
                  throw _iteratorError12;
              }
            }
          } else {
            let mergeMediaStyle2 = function(key5, val3) {
              var _styleState4;
              (_styleState4 = styleState).style || (_styleState4.style = {});
              var didMerge = mergeMediaByImportance(styleState, mediaKeyShort, key5, val3, usedKeys, mediaState[mediaKeyShort], importanceBump, debug);
              didMerge && key5 === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
            };
            var mergeMediaStyle = mergeMediaStyle2, isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
            if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
              if (!mediaState[mediaKeyShort]) {
                process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(`  \u{1F4FA} \u274C DISABLED ${mediaKeyShort}`);
                return;
              }
              process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(`  \u{1F4FA} \u2705 ENABLED ${mediaKeyShort}`);
            }
            var mediaStyle1 = getSubStyle(styleState, key4, val2, !0), importanceBump = 0;
            if (isThemeMedia) {
              if (dynamicThemeAccess = !0, import_constants.isIos && (0, import_config.getSetting)("fastSchemeChange")) {
                var _styleState3;
                (_styleState3 = styleState).style || (_styleState3.style = {});
                var scheme = mediaKeyShort, oppositeScheme = (0, import_getDynamicVal.getOppositeScheme)(mediaKeyShort);
                for (var subKey1 in mediaStyle1) {
                  var _$val1 = (0, import_getDynamicVal.extractValueFromDynamic)(mediaStyle1[subKey1], scheme), oppositeVal = (0, import_getDynamicVal.extractValueFromDynamic)(styleState.style[subKey1], oppositeScheme);
                  mediaStyle1[subKey1] = (0, import_getDynamicVal.getDynamicVal)({
                    scheme,
                    val: _$val1,
                    oppositeVal
                  }), mergeStyle(styleState, subKey1, mediaStyle1[subKey1]);
                }
              } else if (!(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort)))
                return;
            } else if (isGroupMedia) {
              var _componentState_group, groupInfo = (0, import_getGroupPropParts.getGroupPropParts)(mediaKeyShort), groupName = groupInfo.name, groupContext = context == null ? void 0 : context.groups.state[groupName];
              if (!groupContext) {
                process.env.NODE_ENV === "development" && debug && (0, import_log.log)(`No parent with group prop, skipping styles: ${groupName}`);
                return;
              }
              var groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
              if (groupMediaKey) {
                mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
                var mediaState1 = componentGroupState == null ? void 0 : componentGroupState.media, isActive = mediaState1 == null ? void 0 : mediaState1[groupMediaKey];
                if (!mediaState1 && groupContext.layout && (isActive = (0, import_useMedia.mediaKeyMatch)(groupMediaKey, groupContext.layout)), process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(` \u{1F3D8}\uFE0F GROUP media ${groupMediaKey} active? ${isActive}`), !isActive) {
                  for (var pkey1 in mediaStyle1)
                    applyDefaultStyle(pkey1, styleState);
                  return;
                }
                importanceBump = 2;
              }
              if (groupPseudoKey) {
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
                var componentGroupPseudoState = (componentGroupState || // fallback to context initially
                context.groups.state[groupName]).pseudo, isActive1 = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey], priority1 = import_pseudoDescriptors.pseudoPriorities[groupPseudoKey];
                if (process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(` \u{1F3D8}\uFE0F GROUP pseudo ${groupMediaKey} active? ${isActive1}, priority ${priority1}`), !isActive1) {
                  for (var pkey2 in mediaStyle1)
                    applyDefaultStyle(pkey2, styleState);
                  return;
                }
                importanceBump = priority1;
              }
            }
            for (var subKey2 in mediaStyle1) {
              if (subKey2 === "space") {
                space = valInit.space;
                continue;
              }
              if (subKey2[0] === "$") {
                if (!(0, import_isActivePlatform.isActivePlatform)(subKey2) || !(0, import_isActiveTheme.isActiveTheme)(subKey2, themeName)) continue;
                for (var subSubKey in mediaStyle1[subKey2])
                  mergeMediaStyle2(subSubKey, mediaStyle1[subKey2][subSubKey]);
              } else
                mergeMediaStyle2(subKey2, mediaStyle1[subKey2]);
            }
          }
          return;
        }
        if (!isVariant) {
          if (isStyledContextProp)
            return;
          viewProps[key4] = val2;
        }
      }
    }), process.env.NODE_ENV === "development" && debug === "verbose") {
      try {
        (0, import_log.log)(" \u2714\uFE0F expand complete", keyInit), (0, import_log.log)("style", {
          ...styleState.style
        }), (0, import_log.log)("viewProps", {
          ...viewProps
        });
      } catch {
      }
      (0, import_consoleLog.groupEnd)();
    }
  };
  conf = conf || (0, import_config.getConfig)(), import_constants.isWeb && styleProps.isAnimated && conf.animations.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  var { shorthands } = conf, { isHOC, isText, isInput, variants, isReactNative, inlineProps, inlineWhenUnflattened, parentStaticConfig, acceptsClassName } = staticConfig, viewProps = {}, mediaState = styleProps.mediaState || import_useMedia.mediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && import_constants.isWeb && !styleProps.noClass, rulesToInsert = void 0, classNames = {}, pseudos = null, space = props.space, hasMedia = !1, dynamicThemeAccess, pseudoGroups, mediaGroups, className = props.className || "", mediaStylesSeen = 0, validStyles = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? import_helpers.stylePropsText : import_helpers.validStyles);
  process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-setup`;
  var styleState = {
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  if (process.env.IS_STATIC === "is_static") {
    var { fallbackProps } = styleProps;
    fallbackProps && (styleState.props = new Proxy(props, {
      get(_, key4, val2) {
        return Reflect.has(props, key4) ? Reflect.get(props, key4) : Reflect.get(fallbackProps, key4);
      }
    }));
  }
  process.env.NODE_ENV === "development" && debug === "profile" && time`style-state`, process.env.NODE_ENV === "development" && debug && debug !== "profile" && import_constants.isClient && ((0, import_consoleLog.groupCollapsed)("getSplitStyles (collapsed)"), (0, import_log.log)({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    rulesToInsert,
    componentState,
    styleState,
    theme: {
      ...theme
    }
  }), (0, import_consoleLog.groupEnd)());
  var { asChild } = props, { accept } = staticConfig, { noSkip, disableExpandShorthands, noExpand } = styleProps, { webContainerType } = conf.settings, parentVariants = parentStaticConfig == null ? void 0 : parentStaticConfig.variants;
  for (var keyOg in props) _loop(keyOg);
  process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-propsend`;
  var avoidNormalize = styleProps.noNormalize === !1;
  if (!avoidNormalize) {
    if (styleState.style && ((0, import_expandStyles.fixStyles)(styleState.style), !styleProps.noExpand && !styleProps.noMergeStyle && import_constants.isWeb && !isReactNative && (0, import_getCSSStylesAtomic.styleToCSS)(styleState.style)), styleState.flatTransforms) {
      var _styleState;
      (_styleState = styleState).style || (_styleState.style = {}), mergeFlatTransforms(styleState.style, styleState.flatTransforms);
    }
    if (parentSplitStyles) {
      if (0 && shouldDoClasses)
        for (var key in parentSplitStyles.classNames)
          var val;
      if (!shouldDoClasses)
        for (var key1 in parentSplitStyles.style) {
          var _styleState1;
          key1 in classNames || styleState.style && key1 in styleState.style || ((_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key1] = parentSplitStyles.style[key1]);
        }
    }
  }
  if (0)
    var _styleState_style, shouldStringifyTransforms;
  if (0) {
    if (!styleProps.noMergeStyle && styleState.style && shouldDoClasses) {
      var retainedStyles, shouldRetain;
      if (!styleState.style.$$css) {
        var atomic, _iteratorNormalCompletion, _didIteratorError, _iteratorError;
        try {
          for (var _iterator, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0)
            var atomicStyle, _props_animateOnly, _props_animateOnly1, key2, value, identifier, isAnimatedAndAnimateOnly, nonAnimatedAnimateOnly;
        } catch (err) {
        } finally {
        }
      }
    }
    if (isReactNative) {
      if (viewProps.tabIndex === 0)
        var _viewProps, _accessible;
    } else if (viewProps.tabIndex == null)
      var _viewProps_focusable, isFocusable, role;
  }
  var styleProp = props.style;
  if (!styleProps.noMergeStyle && styleProp)
    if (isHOC)
      viewProps.style = normalizeStyle(styleProp);
    else
      for (var isArray = Array.isArray(styleProp), len = isArray ? styleProp.length : 1, i = 0; i < len; i++) {
        var style = isArray ? styleProp[i] : styleProp;
        if (style)
          if (style.$$css)
            Object.assign(styleState.classNames, style);
          else {
            var _styleState2;
            (_styleState2 = styleState).style || (_styleState2.style = {}), Object.assign(styleState.style, normalizeStyle(style));
          }
      }
  var style1 = styleState.style;
  if (style1 != null && style1.fontFamily) {
    var _getFont, faceInfo = (_getFont = (0, import_config.getFont)(style1.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style1.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style1.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style1.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style1.fontWeight, delete style1.fontStyle);
    }
    process.env.NODE_ENV === "development" && debug && debug !== "profile" && (0, import_log.log)(`Found fontFamily native: ${style1.fontFamily}`, faceInfo);
  }
  process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-pre-result`;
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!styleProps.noMergeStyle && !asChildExceptStyleLike) {
    var style2 = styleState.style;
    if (0) {
      var _staticConfig_defaultProps, fontFamily, fontFamilyClassName, groupClassName, componentNameFinal, componentClassName, classList, finalClassName;
      if (!(styleProps.isAnimated && !conf.animations.supportsCSSVars && isReactNative)) {
        if (isReactNative) {
          var cnStyles, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1;
          try {
            for (var _iterator1, _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0)
              var name;
          } catch (err) {
          } finally {
          }
        }
      }
    } else
      style2 && (viewProps.style = style2);
  }
  if (process.env.NODE_ENV === "development" && debug === "verbose" && import_isDevTools.isDevTools) {
    (0, import_consoleLog.groupCollapsed)("\u{1F539} getSplitStyles ===>");
    try {
      var logs = {
        ...result,
        className,
        componentState,
        viewProps,
        rulesToInsert,
        parentSplitStyles
      };
      for (var key3 in logs)
        (0, import_log.log)(key3, logs[key3]);
    } catch {
    }
    (0, import_consoleLog.groupEnd)();
  }
  return process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-done`, result;
};
function mergeFlatTransforms(target, flatTransforms) {
  Object.entries(flatTransforms).sort(function(param, param1) {
    var [a] = param, [b] = param1;
    return (0, import_sortString.sortString)(a, b);
  }).forEach(function(param) {
    var [key, val] = param;
    mergeTransform(target, key, val, !0);
  });
}
function mergeStyle(styleState, key, val) {
  var disableNormalize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, { viewProps, styleProps, staticConfig } = styleState;
  if (key in import_helpers.stylePropsTransform) {
    var _styleState;
    (_styleState = styleState).flatTransforms || (_styleState.flatTransforms = {}), styleState.flatTransforms[key] = val;
  } else {
    var shouldNormalize = import_constants.isWeb && !disableNormalize && !styleProps.noNormalize, out = shouldNormalize ? (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(val, key) : val;
    if (
      // accept is for props not styles
      staticConfig.accept && key in staticConfig.accept
    )
      viewProps[key] = out;
    else {
      var _styleState1;
      (_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key] = // if you dont do this you'll be passing props.transform arrays directly here and then mutating them
      // if theres any flatTransforms later, causing issues (mutating props is bad, in strict mode styles get borked)
      key === "transform" && Array.isArray(out) ? [
        ...out
      ] : out;
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var _loop = function(key1) {
    var val = styleIn[key1];
    key1 = conf2.shorthands[key1] || key1;
    var shouldSkip = !staticConfig.isHOC && key1 in import_skipProps.skipProps && !styleProps.noSkip;
    if (shouldSkip)
      return key = key1, "continue";
    (0, import_propMapper.propMapper)(key1, val, styleState, !1, function(skey, sval) {
      skey in import_helpers.validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in import_helpers.stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(sval, key1);
    }), key = key1;
  }, { staticConfig, conf: conf2, styleProps } = styleState, styleOut = {};
  for (var key in styleIn) _loop(key);
  if (!avoidMergeTransform) {
    if (Array.isArray(styleOut.transform)) {
      var _styleState_style, parentTransform = (_styleState_style = styleState.style) === null || _styleState_style === void 0 ? void 0 : _styleState_style.transform;
      parentTransform && (styleOut.transform = [
        ...parentTransform,
        ...styleOut.transform
      ]);
    }
    styleState.flatTransforms && mergeFlatTransforms(styleOut, styleState.flatTransforms);
  }
  return styleProps.noNormalize || (0, import_expandStyles.fixStyles)(styleOut), styleOut;
}, useInsertEffectCompat = import_constants.isWeb ? import_react.default.useInsertionEffect || import_constants.useIsomorphicLayoutEffect : function() {
}, useSplitStyles = function(a, b, c, d, e, f, g, h, i, j) {
  conf = conf || (0, import_config.getConfig)();
  var res = getSplitStyles(a, b, c, d, e, f, g, h, i, j);
  return res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  if (0)
    var identifier;
}
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = {
  ...Object.fromEntries(Object.entries(import_helpers.tokenCategories.color).map(function(param) {
    var [k, v] = param;
    return [
      k,
      defaultColor
    ];
  })),
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}, lowercaseHyphenate = function(match) {
  return `-${match.toLowerCase()}`;
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (shouldMergeObject) {
    var next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key], viewProps[key] = next;
  } else
    viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump, debugProp) {
  var importance = (0, import_useMedia.getMediaImportanceIfMoreImportant)(mediaKey, key, importancesUsed, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), process.env.NODE_ENV === "development" && debugProp === "verbose" && (0, import_log.log)(`mergeMediaByImportance ${key} importance existing ${importancesUsed[key]} next ${importance}`), importance === null)
    return !1;
  if (importancesUsed[key] = importance, key in import_pseudoDescriptors.pseudoDescriptors) {
    var descriptor = import_pseudoDescriptors.pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name, isDisabled = styleState.componentState[descriptorKey] === !1;
    if (isDisabled)
      return !1;
    for (var subKey in value)
      mergeStyle(styleState, subKey, value[subKey]);
  } else
    mergeStyle(styleState, key, value);
  return !0;
}
function normalizeStyle(style) {
  var out = {};
  for (var key in style) {
    var val = style[key];
    key in import_helpers.stylePropsTransform ? mergeTransform(out, key, val) : out[key] = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(val, key);
  }
  return import_constants.isWeb && Array.isArray(out.transform) && (out.transform = (0, import_transformsToString.transformsToString)(out.transform)), (0, import_expandStyles.fixStyles)(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  var defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
});
//# sourceMappingURL=getSplitStyles.js.map
