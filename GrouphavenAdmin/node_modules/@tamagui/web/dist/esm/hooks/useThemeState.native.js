import { useIsomorphicLayoutEffect } from "@tamagui/constants";
import { createContext, useCallback, useContext, useId, useSyncExternalStore } from "react";
import { getConfig } from "../config.native.js";
import { MISSING_THEME_MESSAGE } from "../constants/constants.native.js";
var ThemeStateContext = createContext(""),
  allListeners = /* @__PURE__ */new Map(),
  listenersByParent = {},
  HasRenderedOnce = /* @__PURE__ */new WeakMap(),
  HadTheme = /* @__PURE__ */new WeakMap(),
  PendingUpdate = /* @__PURE__ */new Map(),
  states = /* @__PURE__ */new Map(),
  localStates = /* @__PURE__ */new Map(),
  shouldForce = !1,
  forceUpdateThemes = function () {
    cacheVersion++, shouldForce = !0, allListeners.forEach(function (cb) {
      return cb();
    });
  },
  getThemeState = function (id) {
    return states.get(id);
  },
  cacheVersion = 0,
  themes = null,
  rootThemeState = null,
  getRootThemeState = function () {
    return rootThemeState;
  },
  useThemeState = function (props) {
    var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
      keys = arguments.length > 2 ? arguments[2] : void 0,
      {
        disable
      } = props,
      parentId = useContext(ThemeStateContext);
    if (!parentId && !isRoot) throw new Error(MISSING_THEME_MESSAGE);
    if (disable) return states.get(parentId) || {
      id: "",
      name: "light",
      theme: getConfig().themes.light,
      inverses: 0
    };
    var id = useId(),
      subscribe = useCallback(function (cb) {
        var _listenersByParent, _parentId;
        return (_listenersByParent = listenersByParent)[_parentId = parentId] || (_listenersByParent[_parentId] = /* @__PURE__ */new Set()), listenersByParent[parentId].add(id), allListeners.set(id, function () {
          PendingUpdate.set(id, shouldForce ? "force" : !0), cb();
        }), function () {
          allListeners.delete(id), listenersByParent[parentId].delete(id), localStates.delete(id), states.delete(id), PendingUpdate.delete(id);
        };
      }, [id, parentId]),
      propsKey = getPropsKey(props),
      getSnapshot = function () {
        var _keys_current,
          _props_needsUpdate,
          local = localStates.get(id),
          needsUpdate = isRoot || props.name === "light" || props.name === "dark" || props.name === null ? !0 : HasRenderedOnce.get(keys) ? !(keys == null || (_keys_current = keys.current) === null || _keys_current === void 0) && _keys_current.size ? !0 : (_props_needsUpdate = props.needsUpdate) === null || _props_needsUpdate === void 0 ? void 0 : _props_needsUpdate.call(props) : !0,
          [rerender, next] = getNextState(local, props, propsKey, isRoot, id, parentId, needsUpdate, PendingUpdate.get(id));
        return PendingUpdate.delete(id), (!local || rerender) && (local = {
          ...next
        }, localStates.set(id, local)), process.env.NODE_ENV === "development" && props.debug && props.debug !== "profile" && (console.groupCollapsed(` ${id} \u{1FA84} ${rerender}`, local.name, ">", next.name), console.info({
          props,
          propsKey,
          isRoot,
          parentId,
          local,
          next,
          needsUpdate
        }), console.groupEnd()), Object.assign(local, next), local.id = id, states.set(id, next), local;
      };
    process.env.NODE_ENV === "development" && globalThis.time && globalThis.time`theme-prep-uses`;
    var state = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
    return useIsomorphicLayoutEffect(function () {
      if (!HasRenderedOnce.get(keys)) {
        HasRenderedOnce.set(keys, !0);
        return;
      }
      if (!propsKey) {
        HadTheme.get(keys) && scheduleUpdate(id), HadTheme.set(keys, !1);
        return;
      }
      if (process.env.NODE_ENV === "development" && props.debug && props.debug !== "profile") {
        var _states_get;
        console.warn(` \xB7 useTheme(${id}) scheduleUpdate`, propsKey, (_states_get = states.get(id)) === null || _states_get === void 0 ? void 0 : _states_get.name);
      }
      scheduleUpdate(id), HadTheme.set(keys, !0);
    }, [keys, propsKey]), state;
  },
  getNextState = function (lastState, props, propsKey) {
    var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
      id = arguments.length > 4 ? arguments[4] : void 0,
      parentId = arguments.length > 5 ? arguments[5] : void 0,
      needsUpdate = arguments.length > 6 ? arguments[6] : void 0,
      pendingUpdate = arguments.length > 7 ? arguments[7] : void 0,
      {
        debug
      } = props,
      parentState = states.get(parentId);
    themes || (themes = getConfig().themes);
    var name = !propsKey && (!lastState || !lastState?.isNew) ? null : getNewThemeName(parentState?.name, props, pendingUpdate === "force" ? !0 : !!needsUpdate),
      isSameAsParent = parentState && (!name || name === parentState.name),
      shouldRerender = !!(needsUpdate && (pendingUpdate || lastState?.name !== parentState?.name));
    if (process.env.NODE_ENV === "development" && debug && debug !== "profile") {
      var message = ` \xB7 useTheme(${id}) => ${name} needsUpdate ${needsUpdate} shouldRerender ${shouldRerender}`;
      console.info(message);
    }
    if (isSameAsParent) return [shouldRerender, {
      ...parentState,
      isNew: !1
    }];
    if (!name) {
      var next = lastState ?? parentState;
      if (!next) throw new Error(MISSING_THEME_MESSAGE);
      if (shouldRerender) {
        var updated = {
          ...(parentState || lastState)
        };
        return [!0, updated];
      }
      return [!1, next];
    }
    var scheme = getScheme(name),
      _parentState_inverses,
      parentInverses = (_parentState_inverses = parentState?.inverses) !== null && _parentState_inverses !== void 0 ? _parentState_inverses : 0,
      isInverse = parentState && scheme !== parentState.scheme,
      inverses = parentInverses + (isInverse ? 1 : 0),
      nextState = {
        id,
        name,
        theme: themes[name],
        scheme,
        parentId,
        parentName: parentState?.name,
        inverses,
        isInverse,
        isNew: !0
      };
    if (isRoot && (rootThemeState = nextState), pendingUpdate !== "force" && lastState && lastState.name === name) return [!1, nextState];
    var shouldAvoidRerender = pendingUpdate !== "force" && lastState && !needsUpdate && nextState.name === lastState.name;
    return process.env.NODE_ENV === "development" && debug && debug !== "profile" && (console.groupCollapsed(` \xB7 useTheme(${id}) \u23ED\uFE0F ${name} shouldAvoidRerender: ${shouldAvoidRerender}`), console.info({
      lastState,
      needsUpdate,
      nextState,
      pendingUpdate
    }), console.groupEnd()), shouldAvoidRerender ? [!1, nextState] : [!0, nextState];
  };
function scheduleUpdate(id) {
  for (var queue = [id], visited = /* @__PURE__ */new Set(); queue.length;) {
    var parent = queue.shift(),
      children = listenersByParent[parent];
    if (children) {
      var _iteratorNormalCompletion = !0,
        _didIteratorError = !1,
        _iteratorError = void 0;
      try {
        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
          var childId = _step.value;
          visited.has(childId) || (visited.add(childId), queue.push(childId));
        }
      } catch (err) {
        _didIteratorError = !0, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
  }
  visited.forEach(function (childId2) {
    var cb = allListeners.get(childId2);
    cb?.();
  });
}
var validSchemes = {
  light: "light",
  dark: "dark"
};
function getScheme(name) {
  return validSchemes[name.split("_")[0]];
}
function getNewThemeName() {
  var parentName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
    {
      name,
      reset,
      componentName,
      inverse,
      debug
    } = arguments.length > 1 ? arguments[1] : void 0,
    forceUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (name && reset) throw new Error(process.env.NODE_ENV === "production" ? "\u274C004" : "Cannot reset and set a new name at the same time.");
  var {
    themes: themes2
  } = getConfig();
  if (reset) {
    var lastPartIndex = parentName.lastIndexOf("_"),
      name1 = lastPartIndex <= 0 ? parentName : parentName.slice(lastPartIndex),
      scheme = parentName.slice(0, lastPartIndex),
      result = themes2[name1] ? name1 : scheme;
    return result;
  }
  var parentParts = parentName.split("_"),
    lastName = parentParts[parentParts.length - 1];
  lastName && lastName[0].toLowerCase() !== lastName[0] && parentParts.pop();
  for (var subNames = [name && componentName ? `${name}_${componentName}` : void 0, name, componentName].filter(Boolean), found = null, max = parentParts.length, i = 0; i <= max; i++) {
    var base = (i === 0 ? parentParts : parentParts.slice(0, -i)).join("_"),
      _iteratorNormalCompletion = !0,
      _didIteratorError = !1,
      _iteratorError = void 0;
    try {
      for (var _iterator = subNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var subName = _step.value,
          potential = base ? `${base}_${subName}` : subName;
        if (potential in themes2) {
          found = potential;
          break;
        }
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    if (found) break;
  }
  if (inverse) {
    found || (found = parentName);
    var scheme1 = found.split("_")[0];
    found = found.replace(new RegExp(`^${scheme1}`), scheme1 === "light" ? "dark" : "light");
  }
  return !forceUpdate && found === parentName &&
  // if its a scheme only sub-theme, we always consider it "new" because it likely inverses
  // and we want to avoid reparenting
  !validSchemes[found] ? null : found;
}
var getPropsKey = function (param) {
    var {
      name,
      reset,
      inverse,
      forceClassName,
      componentName
    } = param;
    return `${name || ""}${inverse || ""}${reset || ""}${forceClassName || ""}${componentName || ""}`;
  },
  hasThemeUpdatingProps = function (props) {
    return "inverse" in props || "name" in props || "reset" in props || "forceClassName" in props;
  };
export { ThemeStateContext, forceUpdateThemes, getRootThemeState, getThemeState, hasThemeUpdatingProps, useThemeState };
//# sourceMappingURL=useThemeState.native.js.map
