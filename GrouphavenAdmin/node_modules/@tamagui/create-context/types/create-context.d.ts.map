{
  "mappings": "AAGA,YAAY,WAAW,OAAO;AAE9B,YAAY;CAAY;CAAG;IAAoB,OAAO,iBAAiB,QAAO;AAE9E,OAAO,iBAAS,cAAc,kCAAkC,MAC9DA,2BACAC,iBAAiB,8BAEhBC,OAAO,mBAAmB,EAAE,UAAU,MAAM,UAAW,MAAK,IAAI,UAChEC,yBAAyB,QAAQ;KA2B/B,aAAaC,OAAO,UAAU,yBAAyB,MAAO;AAEnE,YAAY,MAAM,WAAW,uBAAuB,MAAM,QAAQ,KAAM;AAExE,iBAAiB,YAAY;CAC3B;KACI;AACL;AAED,OAAO,iBAAS,mBACdC,mBACAC,yBAAwB,2BAEvB,kCAAkC,MACjCN,2BACAC,iBAAiB,gCAGfM,OAAO,mBAAmB;CACxB,OAAO,MAAM;CACb,UAAU,MAAM;AACjB,aACS,qBAAqB,IAAI,UAEnCJ,sBACAK,OAAO,MAAM,+BACbC,UAAU;CACR;CACA,WAAW,QAAQ;AACpB,MACE,mBAEP",
  "names": [
    "rootComponentName: string",
    "defaultContext?: ContextValueType",
    "props: ContextValueType & { children: React.ReactNode }",
    "consumerName: string",
    "scope: Scope",
    "scopeName: string",
    "createContextScopeDeps: CreateScope[]",
    "props: ContextValueType & {\n        scope: Scope<ContextValueType>\n        children: React.ReactNode\n      }",
    "scope: Scope<ContextValueType | undefined>",
    "options?: {\n        warn?: boolean\n        fallback?: Partial<ContextValueType>\n      }"
  ],
  "sources": [
    "src/create-context.tsx"
  ],
  "sourcesContent": [
    "// from radix\n// https://github.com/radix-ui/primitives/blob/main/packages/react/context/src/createContext.tsx\n\nimport * as React from 'react'\n\nexport type ScopedProps<P, K extends string> = P & { [Key in `__scope${K}`]?: Scope }\n\nexport function createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n): readonly [\n  (props: ContextValueType & { children: React.ReactNode }) => JSX.Element,\n  (consumerName: string) => Exclude<ContextValueType | undefined, undefined>,\n] {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext)\n\n  function Provider(props: ContextValueType & { children: React.ReactNode }) {\n    const { children, ...context } = props\n    // Only re-memoize when prop values change\n\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType\n    return <Context.Provider value={value}>{children}</Context.Provider>\n  }\n\n  function useContext(consumerName: string): Exclude<typeof context, undefined> {\n    const context = React.useContext(Context)\n    if (context) return context as any\n    if (defaultContext !== undefined) return defaultContext as any\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``)\n  }\n\n  return [Provider, useContext] as const\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope }\n\nexport type Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined\n\nexport interface CreateScope {\n  scopeName: string\n  (): ScopeHook\n}\n\nexport function createContextScope(\n  scopeName: string,\n  createContextScopeDeps: CreateScope[] = []\n): readonly [\n  <ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) => readonly [\n    (\n      props: ContextValueType & {\n        scope: Scope<ContextValueType>\n        children: React.ReactNode\n      }\n    ) => import('react/jsx-runtime').JSX.Element,\n    (\n      consumerName: string,\n      scope: Scope<ContextValueType | undefined>,\n      options?: {\n        warn?: boolean\n        fallback?: Partial<ContextValueType>\n      }\n    ) => ContextValueType,\n  ],\n  CreateScope,\n] {\n  let defaultContexts: any[] = []\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext)\n    const index = defaultContexts.length\n    defaultContexts = [...defaultContexts, defaultContext]\n\n    function Provider(\n      props: ContextValueType & {\n        scope: Scope<ContextValueType>\n        children: React.ReactNode\n      }\n    ) {\n      const { scope, children, ...context } = props\n      const Context = scope?.[scopeName]?.[index] || BaseContext\n      // Only re-memoize when prop values change\n\n      const value = React.useMemo(\n        () => context,\n        Object.values(context)\n      ) as ContextValueType\n      return <Context.Provider value={value}>{children}</Context.Provider>\n    }\n\n    function useContext(\n      consumerName: string,\n      scope: Scope<ContextValueType | undefined>,\n      options?: {\n        warn?: boolean\n        fallback?: Partial<ContextValueType>\n      }\n    ) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext\n      const context = React.useContext(Context)\n      if (context) return context\n      // if a defaultContext wasn't specified, it's a required context.\n      if (defaultContext !== undefined) return defaultContext\n      const missingContextMessage = `\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``\n      // fallback can be given per-hook as well\n      if (options?.fallback) {\n        if (options?.warn !== false) {\n          console.warn(missingContextMessage)\n        }\n        return options.fallback as ContextValueType\n      }\n      throw new Error(missingContextMessage)\n    }\n\n    return [Provider, useContext] as const\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext)\n    })\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      )\n    }\n  }\n\n  createScope.scopeName = scopeName\n\n  return [\n    createContext,\n    composeContextScopes(createScope, ...createContextScopeDeps),\n  ] as const\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0]\n  if (scopes.length === 1) return baseScope\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }))\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n\n        const scopeProps = useScope(overrideScopes)\n        const currentScope = scopeProps[`__scope${scopeName}`]\n        return { ...nextScopes, ...currentScope }\n      }, {})\n\n      return React.useMemo(\n        () => ({ [`__scope${baseScope.scopeName}`]: nextScopes }),\n        [nextScopes]\n      )\n    }\n  }\n\n  createScope.scopeName = baseScope.scopeName\n  return createScope\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n"
  ],
  "version": 3
}