import { join } from "node:path";
let didRegisterOnce = !1;
async function generateThemes(inputFile) {
  const inputFilePath = inputFile[0] === "." ? join(process.cwd(), inputFile) : inputFile;
  didRegisterOnce ? purgeCache(inputFilePath) : (didRegisterOnce = !0, require("esbuild-register/dist/node").register({
    hookIgnoreNodeModules: !1
  }));
  let og = process.env.TAMAGUI_KEEP_THEMES;
  process.env.TAMAGUI_KEEP_THEMES = "1", process.env.TAMAGUI_RUN_THEMEBUILDER = "1";
  try {
    const requiredThemes = require(inputFilePath), themes = requiredThemes.default || requiredThemes.themes || requiredThemes[Object.keys(requiredThemes)[0]];
    return {
      generated: generatedThemesToTypescript(themes)
    };
  } catch (err) {
    console.warn(` \u26A0\uFE0F Error running theme builder:
`, err?.stack || err);
  } finally {
    process.env.TAMAGUI_KEEP_THEMES = og;
  }
}
const dedupedTokens = /* @__PURE__ */ new Map();
function generatedThemesToTypescript(themes) {
  const dedupedThemes = /* @__PURE__ */ new Map(), dedupedThemeToNames = /* @__PURE__ */ new Map();
  let i = 0;
  for (const name in themes) {
    i++;
    const theme = themes[name];
    let j = 0;
    for (const [key2, value] of Object.entries(theme)) {
      i++;
      const uniqueKey = `t${i}${j}`;
      dedupedTokens.has(value) || dedupedTokens.set(value, uniqueKey);
    }
    const key = JSON.stringify(theme);
    dedupedThemes.has(key) ? dedupedThemeToNames.set(key, [...dedupedThemeToNames.get(key), name]) : (dedupedThemes.set(key, theme), dedupedThemeToNames.set(key, [name]));
  }
  if (!themes)
    throw new Error("Didn't find any themes exported or returned");
  const baseKeys = Object.entries(themes.light || themes[Object.keys(themes)[0]]);
  let out = `${`type Theme = {
${baseKeys.map(([k]) => `  ${k}: string;
`).join("")}
}`}
`;
  out += `
function t(a: [number, number][]) {
  let res: Record<string,string> = {}
  for (const [ki, vi] of a) {
    res[ks[ki] as string] = colors[vi] as string
  }
  return res as Theme
}
`, out += `export const colors = [
`;
  let index = 0;
  const valueToIndex = {};
  dedupedTokens.forEach((name, value) => {
    valueToIndex[value] = index, index++, out += `  '${value}',
`;
  }), out += `]

`;
  const keys = baseKeys.map(([k]) => k);
  out += `const ks = [
`, out += keys.map((k) => `'${k}'`).join(`,
`), out += `]

`;
  let nameI = 0, themeTypes = "type ThemeNames =", exported = "export const themes: Record<ThemeNames, Theme> = {";
  return dedupedThemes.forEach((theme) => {
    nameI++;
    const key = JSON.stringify(theme), names = dedupedThemeToNames.get(key), name = `n${nameI}`, baseTheme = `const ${name} = ${objectToJsString(theme, keys, valueToIndex)}`;
    out += `
${baseTheme}`, names.forEach((n) => {
      exported += `
  ${n}: ${name},`, n.toLowerCase() === n && (themeTypes += `
 | '${n}'`);
    });
  }), out += `

${themeTypes}

${exported}
}
`, out;
}
function objectToJsString(obj, keys, valueToIndex) {
  let arrItems = [];
  for (const key in obj) {
    const ki = keys.indexOf(key), vi = valueToIndex[obj[key]];
    arrItems.push(`[${ki}, ${vi}]`);
  }
  return `t([${arrItems.join(",")}])`;
}
function purgeCache(moduleName) {
  searchCache(moduleName, (mod) => {
    delete require.cache[mod.id];
  }), !(!module.constructor || !module.constructor._pathCache) && Object.keys(module.constructor._pathCache).forEach((cacheKey) => {
    cacheKey.indexOf(moduleName) > 0 && delete module.constructor._pathCache[cacheKey];
  });
}
function searchCache(moduleName, callback) {
  let mod = require.resolve(moduleName);
  mod && (mod = require.cache[mod]) !== void 0 && function traverse(mod2, depth = 0) {
    depth > 10 || (mod2.children.forEach((child) => {
      traverse(child, depth + 1);
    }), callback(mod2));
  }(mod);
}
export {
  generateThemes
};
//# sourceMappingURL=generate-themes.js.map
