{
  "mappings": "AAAA,cACE,oBACA,oBACA,cACA,iBACK,oBAAoB;AAM3B,OAAO,iBAAS;CACd,mBAAmB;CACnB,eAAe,eAAe,CAAE;EAEhCA,UAAU,eAAe,qBACzBC,wBACAC,YAAY,YACZC,UAAU,oBACVC,eACA,yBAEC,aAAa,mBAAmB;AA2BnC,OAAO,iBAAS;CACd,mBAAmB;CACnB,eAAe,eAAe,CAAE;EAEhCC,SAAS,oBACTH,YAAY,YACZC,UAAU,oBACVC,eACA,yBAEC,aAAa,mBAAmB;KAyC9B;CAAa;CAAY;OAAgB,4BAC1C,sBACS,2BAA2B;KAEnC;CAAY;CAAuC,cAAc;KACpEE,MAAM,MACNC,OAAO,UACJ,iBAAiB,MAAO;AAE7B,OAAO,iBAAS;CACd,eAAe,iBAAiB,aAAc;CAC9C,oBAAoB,kBAAkB,QAAQ,aAAa;EAE3DC,QAAQ,QACRC,aAAa,cACZ,YACA,OAAO,mBAAmB,cAAc,WAAW,iBAAgB,aAAa",
  "names": [
    "palettes: Record<string, CreateThemePalette>",
    "defaultPalette: string",
    "definition: Definition",
    "options?: CreateThemeOptions",
    "name?: string",
    "palette: CreateThemePalette",
    "name: Name",
    "theme: Theme",
    "themes: Themes",
    "getChildren: GetChildren"
  ],
  "sources": [
    "src/createTheme.tsx"
  ],
  "sourcesContent": [
    "import type {\n  CreateThemeOptions,\n  CreateThemePalette,\n  GenericTheme,\n  ThemeMask,\n} from './createThemeTypes'\nimport { isMinusZero } from './isMinusZero'\nimport { setThemeInfo } from './themeInfo'\n\nconst identityCache = new Map()\n\nexport function createThemeWithPalettes<\n  Definition extends ThemeMask,\n  Extras extends GenericTheme = {},\n>(\n  palettes: Record<string, CreateThemePalette>,\n  defaultPalette: string,\n  definition: Definition,\n  options?: CreateThemeOptions,\n  name?: string,\n  skipCache = false\n): {\n  [key in keyof Definition | keyof Extras]: string\n} {\n  if (!palettes[defaultPalette]) {\n    throw new Error(`No pallete: ${defaultPalette}`)\n  }\n  const newDef = { ...definition }\n  for (const key in definition) {\n    let val = definition[key]\n    if (typeof val === 'string' && val[0] === '$') {\n      const [altPaletteName$, altPaletteIndex] = val.split('.')\n      const altPaletteName = altPaletteName$.slice(1)\n      const parentName = defaultPalette.split('_')[0]\n      const altPalette =\n        palettes[altPaletteName] || palettes[`${parentName}_${altPaletteName}`]\n\n      if (altPalette) {\n        const next = getValue(altPalette, +altPaletteIndex)\n        if (typeof next !== 'undefined') {\n          newDef[key] = next as any\n        }\n      }\n    }\n  }\n\n  return createTheme(palettes[defaultPalette], newDef, options, name, skipCache)\n}\n\nexport function createTheme<\n  Definition extends ThemeMask,\n  Extras extends GenericTheme = {},\n>(\n  palette: CreateThemePalette,\n  definition: Definition,\n  options?: CreateThemeOptions,\n  name?: string,\n  skipCache = false\n): {\n  [key in keyof Definition | keyof Extras]: string\n} {\n  const cacheKey = skipCache ? '' : JSON.stringify([name, palette, definition, options])\n  if (!skipCache) {\n    if (identityCache.has(cacheKey)) {\n      return identityCache.get(cacheKey)\n    }\n  }\n\n  const theme = {\n    ...(Object.fromEntries(\n      Object.entries(definition).map(([key, offset]) => {\n        return [key, getValue(palette, offset)]\n      })\n    ) as any),\n    ...options?.nonInheritedValues,\n  }\n\n  setThemeInfo(theme, { palette, definition, options, name })\n\n  if (cacheKey) {\n    identityCache.set(cacheKey, theme)\n  }\n\n  return theme\n}\n\nconst getValue = (palette: CreateThemePalette, value: string | number) => {\n  if (!palette) {\n    throw new Error(`No palette!`)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  const max = palette.length - 1\n  const isPositive = value === 0 ? !isMinusZero(value) : value >= 0\n  const next = isPositive ? value : max + value\n  const index = Math.min(Math.max(0, next), max)\n  return palette[index]\n}\n\ntype SubThemeKeys<ParentKeys, ChildKeys> = `${ParentKeys extends string\n  ? ParentKeys\n  : never}_${ChildKeys extends string ? ChildKeys : never}`\n\ntype ChildGetter<Name extends string | number | symbol, Theme extends GenericTheme> = (\n  name: Name,\n  theme: Theme\n) => { [key: string]: Theme }\n\nexport function addChildren<\n  Themes extends { [key: string]: GenericTheme },\n  GetChildren extends ChildGetter<keyof Themes, Themes[keyof Themes]>,\n>(\n  themes: Themes,\n  getChildren: GetChildren\n): Themes & {\n  [key in SubThemeKeys<keyof Themes, keyof ReturnType<GetChildren>>]: Themes[keyof Themes]\n} {\n  const out = { ...themes }\n  for (const key in themes) {\n    const subThemes = getChildren(key, themes[key])\n    for (const sKey in subThemes) {\n      out[`${key}_${sKey}`] = subThemes[sKey] as any\n    }\n  }\n  return out as any\n}\n"
  ],
  "version": 3
}