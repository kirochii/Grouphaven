import { useComposedRefs } from "@tamagui/compose-refs";
import { useIsomorphicLayoutEffect } from "@tamagui/constants";
import { Stack, View as TamaguiView, createStyledContext, getVariableValue, styled, useProps } from "@tamagui/core";
import { arrow, autoUpdate, flip, offset as offsetFn, platform, shift, useFloating, size as sizeMiddleware } from "@tamagui/floating";
import { getSpace } from "@tamagui/get-token";
import { ThemeableStack, YStack } from "@tamagui/stacks";
import "@tamagui/start-transition";
import * as React from "react";
import { jsx } from "react/jsx-runtime";
const PopperContext = createStyledContext({}),
  {
    useStyledContext: usePopperContext,
    Provider: PopperProvider
  } = PopperContext,
  checkFloating = void 0,
  setupOptions = {};
function setupPopper(options) {
  Object.assign(setupOptions, options);
}
function Popper(props) {
  const {
      children,
      size,
      strategy = "absolute",
      placement = "bottom",
      stayInFrame,
      allowFlip,
      offset,
      disableRTL,
      resize,
      __scopePopper
    } = props,
    [arrowEl, setArrow] = React.useState(null),
    [arrowSize, setArrowSize] = React.useState(0),
    offsetOptions = offset ?? arrowSize,
    floatingStyle = React.useRef({});
  let floating = useFloating({
    strategy,
    placement,
    sameScrollView: !1,
    // this only takes effect on native
    whileElementsMounted: autoUpdate,
    platform: disableRTL ?? setupOptions.disableRTL ? {
      ...platform,
      isRTL(element) {
        return !1;
      }
    } : platform,
    middleware: [stayInFrame ? shift(typeof stayInFrame == "boolean" ? {} : stayInFrame) : null, allowFlip ? flip(typeof allowFlip == "boolean" ? {} : allowFlip) : null, arrowEl ? arrow({
      element: arrowEl
    }) : null, typeof offsetOptions < "u" ? offsetFn(offsetOptions) : null, checkFloating, resize ? sizeMiddleware({
      apply({
        availableHeight,
        availableWidth
      }) {
        Object.assign(floatingStyle.current, {
          maxHeight: `${availableHeight}px`,
          maxWidth: `${availableWidth}px`
        });
        const floatingChild = floating.refs.floating.current?.firstChild;
        floatingChild && floatingChild instanceof HTMLElement && Object.assign(floatingChild.style, floatingStyle.current);
      },
      ...(typeof resize == "object" && resize)
    }) : null].filter(Boolean)
  });
  floating = React.useMemo(() => {
    const og = floating.getFloatingProps;
    return resize && og && (floating.getFloatingProps = props2 => og({
      ...props2,
      style: {
        ...props2.style,
        ...floatingStyle.current
      }
    })), floating;
  }, [floating, resize ? JSON.stringify(resize) : null]);
  const {
      middlewareData
    } = floating,
    popperContext = {
      size,
      arrowRef: setArrow,
      arrowStyle: middlewareData.arrow,
      onArrowSize: setArrowSize,
      scope: __scopePopper,
      hasFloating: middlewareData.checkFloating?.hasFloating,
      ...floating
    };
  return /* @__PURE__ */jsx(PopperProvider, {
    ...popperContext,
    children
  });
}
const PopperAnchor = YStack.extractable(React.forwardRef(function (props, forwardedRef) {
    const {
        virtualRef,
        __scopePopper,
        ...anchorProps
      } = props,
      {
        getReferenceProps,
        refs
      } = usePopperContext(__scopePopper),
      ref = React.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref, refs.setReference);
    React.useEffect(() => {
      virtualRef && refs.setReference(virtualRef.current);
    }, [virtualRef]);
    const stackProps = {
      ref: composedRefs,
      ...anchorProps
    };
    return /* @__PURE__ */jsx(TamaguiView, {
      ...(getReferenceProps ? getReferenceProps(stackProps) : stackProps)
    });
  })),
  PopperContentFrame = styled(ThemeableStack, {
    name: "PopperContent",
    variants: {
      unstyled: {
        false: {
          size: "$true",
          backgroundColor: "$background",
          alignItems: "center",
          radiused: !0
        }
      },
      size: {
        "...size": (val, {
          tokens
        }) => ({
          padding: tokens.space[val],
          borderRadius: tokens.radius[val]
        })
      }
    },
    defaultVariants: {
      unstyled: process.env.TAMAGUI_HEADLESS === "1"
    }
  }),
  PopperContent = React.forwardRef(function (props, forwardedRef) {
    const {
        __scopePopper,
        enableAnimationForPositionChange,
        ...rest
      } = props,
      {
        strategy,
        placement,
        refs,
        x,
        y,
        getFloatingProps,
        size
      } = usePopperContext(__scopePopper),
      contentRefs = useComposedRefs(refs.setFloating, forwardedRef),
      [needsMeasure, setNeedsMeasure] = React.useState(enableAnimationForPositionChange);
    useIsomorphicLayoutEffect(() => {
      x && y && setNeedsMeasure(!1);
    }, [enableAnimationForPositionChange, x, y]);
    const frameProps = {
        ref: contentRefs,
        x: x || 0,
        y: y || 0,
        top: 0,
        left: 0,
        position: strategy,
        opacity: !0 ? 1 : 0,
        ...(enableAnimationForPositionChange && {
          // apply animation but disable it on initial render to avoid animating from 0 to the first position
          animation: rest.animation,
          animateOnly: needsMeasure ? [] : rest.animateOnly,
          animatePresence: !1
        }),
        ...(x === 0 && y === 0 && {
          opacity: 0,
          animateOnly: []
        })
      },
      {
        style,
        ...floatingProps
      } = getFloatingProps ? getFloatingProps(frameProps) : frameProps;
    return /* @__PURE__ */jsx(Stack, {
      ...floatingProps,
      children: /* @__PURE__ */jsx(PopperContentFrame, {
        "data-placement": placement,
        "data-strategy": strategy,
        contain: "layout",
        size,
        ...style,
        ...rest
      }, "popper-content-frame")
    });
  }),
  PopperArrowFrame = styled(YStack, {
    name: "PopperArrow",
    variants: {
      unstyled: {
        false: {
          borderColor: "$borderColor",
          backgroundColor: "$background",
          position: "relative"
        }
      }
    },
    defaultVariants: {
      unstyled: process.env.TAMAGUI_HEADLESS === "1"
    }
  }),
  PopperArrowOuterFrame = styled(YStack, {
    name: "PopperArrowOuter",
    variants: {
      unstyled: {
        false: {
          position: "absolute",
          zIndex: 1e6,
          pointerEvents: "none",
          overflow: "hidden",
          alignItems: "center",
          justifyContent: "center"
        }
      }
    },
    defaultVariants: {
      unstyled: process.env.TAMAGUI_HEADLESS === "1"
    }
  }),
  opposites = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  },
  PopperArrow = PopperArrowFrame.styleable(function (propsIn, forwardedRef) {
    const {
        __scopePopper,
        ...rest
      } = propsIn,
      props = useProps(rest),
      {
        offset,
        size: sizeProp,
        borderWidth = 0,
        ...arrowProps
      } = props,
      context = usePopperContext(__scopePopper),
      sizeVal = typeof sizeProp == "number" ? sizeProp : getVariableValue(getSpace(sizeProp ?? context.size, {
        shift: -2,
        bounds: [2]
      })),
      size = Math.max(0, +sizeVal),
      {
        placement
      } = context,
      refs = useComposedRefs(context.arrowRef, forwardedRef),
      x = context.arrowStyle?.x || 0,
      y = context.arrowStyle?.y || 0,
      primaryPlacement = placement ? placement.split("-")[0] : "top",
      arrowStyle = {
        x,
        y,
        width: size,
        height: size
      },
      innerArrowStyle = {},
      isVertical = primaryPlacement === "bottom" || primaryPlacement === "top";
    if (primaryPlacement) {
      arrowStyle[isVertical ? "width" : "height"] = size * 2;
      const oppSide = opposites[primaryPlacement];
      oppSide && (arrowStyle[oppSide] = -size, innerArrowStyle[oppSide] = size / 2), (oppSide === "top" || oppSide === "bottom") && (arrowStyle.left = 0), (oppSide === "left" || oppSide === "right") && (arrowStyle.top = 0), useIsomorphicLayoutEffect(() => {
        context.onArrowSize?.(size);
      }, [size, context.onArrowSize]);
    }
    return /* @__PURE__ */jsx(PopperArrowOuterFrame, {
      ref: refs,
      ...arrowStyle,
      children: /* @__PURE__ */jsx(PopperArrowFrame, {
        width: size,
        height: size,
        ...arrowProps,
        ...innerArrowStyle,
        rotate: "45deg",
        ...(primaryPlacement === "bottom" && {
          borderLeftWidth: borderWidth,
          borderTopWidth: borderWidth
        }),
        ...(primaryPlacement === "top" && {
          borderBottomWidth: borderWidth,
          borderRightWidth: borderWidth
        }),
        ...(primaryPlacement === "right" && {
          borderLeftWidth: borderWidth,
          borderBottomWidth: borderWidth
        }),
        ...(primaryPlacement === "left" && {
          borderTopWidth: borderWidth,
          borderRightWidth: borderWidth
        })
      })
    });
  });
export { Popper, PopperAnchor, PopperArrow, PopperContent, PopperContentFrame, PopperContext, PopperProvider, setupPopper, usePopperContext };
//# sourceMappingURL=Popper.mjs.map
