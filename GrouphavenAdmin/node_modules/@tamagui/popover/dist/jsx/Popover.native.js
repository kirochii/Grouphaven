import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import "@tamagui/polyfill-dev";
import { Adapt, AdaptParent, AdaptPortalContents, ProvideAdaptContext, useAdaptContext, useAdaptIsActive } from "@tamagui/adapt";
import { Animate } from "@tamagui/animate";
import { ResetPresence } from "@tamagui/animate-presence";
import { hideOthers } from "@tamagui/aria-hidden";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import { Stack, Theme, View, createShallowSetState, createStyledContext, useEvent, useGet, useThemeName } from "@tamagui/core";
import { FloatingOverrideContext } from "@tamagui/floating";
import "@tamagui/focus-scope";
import { composeEventHandlers, withStaticProperties } from "@tamagui/helpers";
import { Popper, PopperAnchor, PopperArrow, PopperContent, PopperContentFrame, PopperContext, usePopperContext } from "@tamagui/popper";
import { Portal, resolveViewZIndex } from "@tamagui/portal";
import "@tamagui/remove-scroll";
import { Sheet, SheetController } from "@tamagui/sheet";
import { YStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import { StackZIndexContext } from "@tamagui/z-index-stack";
import * as React from "react";
import { Platform, ScrollView } from "react-native";
import { useFloatingContext } from "./useFloatingContext";
var POPOVER_SCOPE = "PopoverScope", PopoverContext = createStyledContext({}), usePopoverContext = PopoverContext.useStyledContext, PopoverAnchor = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover), { onCustomAnchorAdd, onCustomAnchorRemove } = context || {};
  return React.useEffect(function() {
    return onCustomAnchorAdd(), function() {
      return onCustomAnchorRemove();
    };
  }, [
    onCustomAnchorAdd,
    onCustomAnchorRemove
  ]), /* @__PURE__ */ _jsx(PopperAnchor, {
    __scopePopper: __scopePopover || POPOVER_SCOPE,
    ...rest,
    ref: forwardedRef
  });
}), PopoverTrigger = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover), anchorTo = context.anchorTo, composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
  if (!props.children)
    return null;
  var trigger = /* @__PURE__ */ _jsx(View, {
    "aria-expanded": context.open,
    // TODO not matching
    // aria-controls={context.contentId}
    "data-state": getState(context.open),
    ...rest,
    // @ts-ignore
    ref: composedTriggerRef,
    onPress: composeEventHandlers(props.onPress, context.onOpenToggle)
  }), virtualRef = React.useMemo(function() {
    return anchorTo ? {
      current: {
        getBoundingClientRect: function() {
          return isWeb ? DOMRect.fromRect(anchorTo) : anchorTo;
        },
        ...!isWeb && {
          measure: function(c) {
            return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
          },
          measureInWindow: function(c) {
            return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
          }
        }
      }
    } : null;
  }, [
    context.anchorTo,
    anchorTo == null ? void 0 : anchorTo.x,
    anchorTo == null ? void 0 : anchorTo.y,
    anchorTo == null ? void 0 : anchorTo.x,
    anchorTo == null ? void 0 : anchorTo.height,
    anchorTo == null ? void 0 : anchorTo.width
  ]);
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ _jsx(PopperAnchor, {
    ...virtualRef && {
      virtualRef
    },
    __scopePopper: __scopePopover || POPOVER_SCOPE,
    asChild: rest.asChild,
    children: trigger
  });
}), PopoverContent = PopperContentFrame.extractable(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { allowPinchZoom, trapFocus, disableRemoveScroll = !0, zIndex, __scopePopover, ...contentImplProps } = props, context = usePopoverContext(__scopePopover), contentRef = React.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), isRightClickOutsideRef = React.useRef(!1), [isFullyHidden, setIsFullyHidden] = React.useState(!context.open);
  if (context.open && isFullyHidden && setIsFullyHidden(!1), React.useEffect(function() {
    if (context.open) {
      var content = contentRef.current;
      if (content) return hideOthers(content);
    }
  }, [
    context.open
  ]), !context.keepChildrenMounted && isFullyHidden)
    return null;
  var _contentImplProps_pointerEvents;
  return /* @__PURE__ */ _jsx(PopoverContentPortal, {
    __scopePopover,
    zIndex,
    children: /* @__PURE__ */ _jsx(Stack, {
      pointerEvents: context.open ? (_contentImplProps_pointerEvents = contentImplProps.pointerEvents) !== null && _contentImplProps_pointerEvents !== void 0 ? _contentImplProps_pointerEvents : "auto" : "none",
      children: /* @__PURE__ */ _jsx(PopoverContentImpl, {
        ...contentImplProps,
        disableRemoveScroll,
        ref: composedRefs,
        setIsFullyHidden,
        __scopePopover,
        // we make sure we're not trapping once it's been closed
        // (closed !== unmounted when animating out)
        trapFocus: trapFocus ?? context.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: props.onCloseAutoFocus === !1 ? void 0 : composeEventHandlers(props.onCloseAutoFocus, function(event) {
          var _context_triggerRef_current;
          event.defaultPrevented || (event.preventDefault(), isRightClickOutsideRef.current || (_context_triggerRef_current = context.triggerRef.current) === null || _context_triggerRef_current === void 0 || _context_triggerRef_current.focus());
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, function(event) {
          var originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.current = isRightClick;
        }, {
          checkDefaultPrevented: !1
        }),
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        onFocusOutside: composeEventHandlers(props.onFocusOutside, function(event) {
          return event.preventDefault();
        }, {
          checkDefaultPrevented: !1
        })
      })
    })
  });
}));
function PopoverRepropagateContext(props) {
  return /* @__PURE__ */ _jsx(PopperContext.Provider, {
    scope: props.scope,
    ...props.popperContext,
    children: /* @__PURE__ */ _jsx(PopoverContext.Provider, {
      ...props.context,
      children: /* @__PURE__ */ _jsx(ProvideAdaptContext, {
        ...props.adaptContext,
        children: props.children
      })
    })
  });
}
function PopoverContentPortal(props) {
  var { __scopePopover } = props, zIndex = props.zIndex, context = usePopoverContext(__scopePopover), popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE), themeName = useThemeName(), adaptContext = useAdaptContext(), contents = props.children;
  return (Platform.OS === "android" || Platform.OS === "ios") && (contents = /* @__PURE__ */ _jsx(PopoverRepropagateContext, {
    scope: __scopePopover || POPOVER_SCOPE,
    popperContext,
    context,
    adaptContext,
    children: props.children
  })), /* @__PURE__ */ _jsx(Portal, {
    stackZIndex: !0,
    zIndex,
    children: (
      /* forceClassName avoids forced re-mount renders for some reason... see the HeadMenu as you change tints a few times */
      /* without this you'll see the site menu re-rendering. It must be something in wrapping children in Theme */
      /* @__PURE__ */ _jsxs(Theme, {
        forceClassName: !0,
        name: themeName,
        children: [
          !!context.open && !context.breakpointActive && /* @__PURE__ */ _jsx(YStack, {
            fullscreen: !0,
            onPress: composeEventHandlers(props.onPress, context.onOpenToggle)
          }),
          /* @__PURE__ */ _jsx(StackZIndexContext, {
            zIndex: resolveViewZIndex(zIndex),
            children: contents
          })
        ]
      })
    )
  });
}
var PopoverContentImpl = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { trapFocus, __scopePopover, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, disableFocusScope, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, children, disableRemoveScroll, freezeContentsWhenHidden, setIsFullyHidden, ...contentProps } = props, context = usePopoverContext(__scopePopover), { open, keepChildrenMounted } = context, popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE), handleExitComplete = React.useCallback(function() {
    setIsFullyHidden == null || setIsFullyHidden(!0);
  }, [
    setIsFullyHidden
  ]), contents = /* @__PURE__ */ _jsx(ResetPresence, {
    children
  });
  if (context.breakpointActive) {
    var childrenWithoutScrollView = React.Children.toArray(children).map(function(child) {
      return /* @__PURE__ */ React.isValidElement(child) && child.type === ScrollView ? child.props.children : child;
    });
    return /* @__PURE__ */ _jsx(AdaptPortalContents, {
      children: /* @__PURE__ */ _jsx(PopperContext.Provider, {
        scope: __scopePopover || POPOVER_SCOPE,
        ...popperContext,
        children: childrenWithoutScrollView
      })
    });
  }
  return /* @__PURE__ */ _jsx(Animate, {
    type: "presence",
    present: !!open,
    keepChildrenMounted,
    onExitComplete: handleExitComplete,
    children: /* @__PURE__ */ _jsx(PopperContent, {
      __scopePopper: __scopePopover || POPOVER_SCOPE,
      "data-state": getState(open),
      id: context.contentId,
      ref: forwardedRef,
      ...contentProps,
      children: contents
    }, context.contentId)
  });
});
var PopoverClose = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover);
  return /* @__PURE__ */ _jsx(YStack, {
    ...rest,
    ref: forwardedRef,
    componentName: "PopoverClose",
    onPress: composeEventHandlers(props.onPress, function() {
      var _context_onOpenChange;
      return context == null || (_context_onOpenChange = context.onOpenChange) === null || _context_onOpenChange === void 0 ? void 0 : _context_onOpenChange.call(context, !1, "press");
    })
  });
}), PopoverArrow = PopperArrow.styleable(function(props, forwardedRef) {
  var { __scopePopover, ...rest } = props, isAdapted = useAdaptIsActive();
  return isAdapted ? null : /* @__PURE__ */ _jsx(PopperArrow, {
    __scopePopper: __scopePopover || POPOVER_SCOPE,
    componentName: "PopoverArrow",
    ...rest,
    ref: forwardedRef
  });
}), Popover = withStaticProperties(/* @__PURE__ */ React.forwardRef(function(props, ref) {
  var id = React.useId();
  return /* @__PURE__ */ _jsx(AdaptParent, {
    scope: `${id}PopoverContents`,
    portal: !0,
    children: /* @__PURE__ */ _jsx(PopoverInner, {
      ref,
      id,
      ...props
    })
  });
}), {
  Anchor: PopoverAnchor,
  Arrow: PopoverArrow,
  Trigger: PopoverTrigger,
  Content: PopoverContent,
  Close: PopoverClose,
  Adapt,
  ScrollView,
  Sheet: Sheet.Controlled
}), PopoverInner = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { children, open: openProp, defaultOpen, onOpenChange, __scopePopover, keepChildrenMounted, hoverable, disableFocus, id, ...restProps } = props, triggerRef = React.useRef(null), [hasCustomAnchor, setHasCustomAnchor] = React.useState(!1), viaRef = React.useRef(), [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen || !1,
    onChange: function(val) {
      onOpenChange == null || onOpenChange(val, viaRef.current);
    }
  }), handleOpenChange = useEvent(function(val, via) {
    viaRef.current = via, setOpen(val);
  }), isAdapted = useAdaptIsActive(), floatingContext = useFloatingContext({
    open,
    setOpen: handleOpenChange,
    disable: isAdapted,
    hoverable,
    disableFocus
  }), [anchorTo, setAnchorToRaw] = React.useState(), setAnchorTo = createShallowSetState(setAnchorToRaw);
  React.useImperativeHandle(forwardedRef, function() {
    return {
      anchorTo: setAnchorTo,
      toggle: function() {
        return setOpen(function(prev) {
          return !prev;
        });
      },
      open: function() {
        return setOpen(!0);
      },
      close: function() {
        return setOpen(!1);
      },
      setOpen
    };
  });
  var popoverContext = {
    id,
    contentId: React.useId(),
    triggerRef,
    open,
    breakpointActive: isAdapted,
    onOpenChange: handleOpenChange,
    onOpenToggle: useEvent(function() {
      open && isAdapted || setOpen(!open);
    }),
    hasCustomAnchor,
    anchorTo,
    onCustomAnchorAdd: React.useCallback(function() {
      return setHasCustomAnchor(!0);
    }, []),
    onCustomAnchorRemove: React.useCallback(function() {
      return setHasCustomAnchor(!1);
    }, []),
    keepChildrenMounted
  }, contents = /* @__PURE__ */ _jsx(Popper, {
    __scopePopper: __scopePopover || POPOVER_SCOPE,
    stayInFrame: !0,
    ...restProps,
    children: /* @__PURE__ */ _jsx(PopoverContext.Provider, {
      scope: __scopePopover,
      ...popoverContext,
      children: /* @__PURE__ */ _jsx(PopoverSheetController, {
        onOpenChange: setOpen,
        children
      })
    })
  });
  return /* @__PURE__ */ _jsx(_Fragment, {
    children: isWeb ? /* @__PURE__ */ _jsx(FloatingOverrideContext.Provider, {
      value: floatingContext,
      children: contents
    }) : contents
  });
});
function getState(open) {
  return open ? "open" : "closed";
}
var PopoverSheetController = function(param) {
  var { __scopePopover, ...props } = param, context = usePopoverContext(__scopePopover), showSheet = useShowPopoverSheet(context), breakpointActive = context.breakpointActive, getShowSheet = useGet(showSheet);
  return /* @__PURE__ */ _jsx(SheetController, {
    onOpenChange: function(val) {
      if (getShowSheet()) {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
      }
    },
    open: context.open,
    hidden: breakpointActive === !1,
    children: props.children
  });
}, useShowPopoverSheet = function(context) {
  var isAdapted = useAdaptIsActive();
  return context.open === !1 ? !1 : isAdapted;
};
export {
  Popover,
  PopoverAnchor,
  PopoverArrow,
  PopoverClose,
  PopoverContent,
  PopoverContext,
  PopoverTrigger,
  usePopoverContext
};
//# sourceMappingURL=Popover.js.map
