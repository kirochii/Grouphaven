{
  "mappings": "AAGA,cAAc,WAAqB,iBAA6B,aAAa;AAQ7E,iBAAiB,sBAAsB;CACrC;CACA;;CAEA,eAAe;;CAEf,cAAc;AACf;AASD,eAAe,SAAS,eACtBA,KAAK,WACLC,YAAY,wBACX",
  "names": [
    "api: ConfigAPI",
    "rawOptions: FullySpecifiedOptions"
  ],
  "sources": [
    "src/index.ts"
  ],
  "sourcesContent": [
    "import { existsSync, lstatSync } from 'node:fs'\nimport { dirname, extname, resolve } from 'node:path'\n\nimport type { ConfigAPI, NodePath, PluginObj, PluginPass } from '@babel/core'\nimport type {\n  ExportAllDeclaration,\n  ExportNamedDeclaration,\n  Import,\n  ImportDeclaration,\n} from '@babel/types'\n\nexport interface FullySpecifiedOptions {\n  ensureFileExists: boolean\n  esExtensionDefault: string\n  /** List of all extensions which we try to find. */\n  tryExtensions: Array<string>\n  /** List of extensions that can run in Node.js or in the Browser. */\n  esExtensions: Array<string>\n}\n\nconst DEFAULT_OPTIONS = {\n  ensureFileExists: true,\n  esExtensionDefault: '.mjs',\n  tryExtensions: ['.js'],\n  esExtensions: ['.mjs'],\n}\n\nexport default function FullySpecified(\n  api: ConfigAPI,\n  rawOptions: FullySpecifiedOptions\n): PluginObj {\n  api.assertVersion(7)\n\n  const options = { ...DEFAULT_OPTIONS, ...rawOptions }\n\n  /** For `import ... from '...'`. */\n  const importDeclarationVisitor = (\n    path: NodePath<ImportDeclaration>,\n    state: PluginPass\n  ) => {\n    const filePath = state.file.opts.filename\n    if (!filePath) return // cannot determine file path therefore cannot proceed\n\n    const { node } = path\n    if (node.importKind === 'type') return // is a type-only import, skip\n\n    const originalModuleSpecifier = node.source.value\n    const fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(\n      originalModuleSpecifier,\n      {\n        filePath,\n        options,\n      }\n    )\n\n    if (fullySpecifiedModuleSpecifier) {\n      node.source.value = fullySpecifiedModuleSpecifier\n    }\n  }\n\n  /** For `export ... from '...'`. */\n  const exportDeclarationVisitor = (\n    path: NodePath<ExportNamedDeclaration> | NodePath<ExportAllDeclaration>,\n    state: PluginPass\n  ) => {\n    const filePath = state.file.opts.filename\n    if (!filePath) return // cannot determine file path therefore cannot proceed\n\n    const { node } = path\n    if (node.exportKind === 'type') return // is a type-only export, skip\n\n    const source = node.source\n    if (!source) return // is not a re-export, skip\n\n    const originalModuleSpecifier = source.value\n    const fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(\n      originalModuleSpecifier,\n      {\n        filePath,\n        options,\n      }\n    )\n\n    if (fullySpecifiedModuleSpecifier) {\n      source.value = fullySpecifiedModuleSpecifier\n    }\n  }\n\n  /** For dynamic `import()`s. */\n  const importVisitor = (path: NodePath<Import>, state) => {\n    const filePath = state.file.opts.filename\n    if (!filePath) return // cannot determine file path therefore cannot proceed\n\n    const parent = path.parent\n    if (parent.type !== 'CallExpression') {\n      return // we expect the usage of `import` is a call to it, e.g.: `import('...')`, other usages are not supported\n    }\n\n    const firstArgOfImportCall = parent.arguments[0]\n    if (firstArgOfImportCall.type !== 'StringLiteral') {\n      return // we expect the first argument of `import` to be a string, e.g.: `import('./myModule')`, other types are not supported\n    }\n\n    const originalModuleSpecifier = firstArgOfImportCall.value\n    const fullySpecifiedModuleSpecifier = getFullySpecifiedModuleSpecifier(\n      originalModuleSpecifier,\n      {\n        filePath,\n        options,\n      }\n    )\n\n    if (fullySpecifiedModuleSpecifier) {\n      firstArgOfImportCall.value = fullySpecifiedModuleSpecifier\n    }\n  }\n\n  return {\n    name: 'babel-plugin-fully-specified',\n    visitor: {\n      ImportDeclaration: importDeclarationVisitor,\n      ExportNamedDeclaration: exportDeclarationVisitor,\n      ExportAllDeclaration: exportDeclarationVisitor,\n      Import: importVisitor,\n    },\n  }\n}\n\n/**\n * Returns a fully specified [module specifier](https://tc39.es/ecma262/multipage/ecmascript-language-scripts-and-modules.html#prod-ModuleSpecifier) (or `null` if it can't be determined or shouldn't be transformed).\n */\nfunction getFullySpecifiedModuleSpecifier(\n  /**\n   * The original module specifier in the code.\n   *\n   * For example, `'./foo'` for `import { foo } from './foo'`.\n   */\n  originalModuleSpecifier: string,\n  {\n    filePath,\n    options,\n  }: {\n    /**\n     * The absolute file path of the file being transformed.\n     *\n     * Normally this can be obtained from the 2nd parameter in a visitor function (often named as `state`): `state.file.opts.filename`.\n     */\n    filePath: string\n    /** Options that users pass to babel-plugin-fully-specified. */\n    options: FullySpecifiedOptions\n  }\n): string | null {\n  const fileExt = extname(filePath)\n  const fileDir = dirname(filePath)\n\n  const isDirectory = isLocalDirectory(resolve(fileDir, originalModuleSpecifier))\n\n  const currentModuleExtension = extname(originalModuleSpecifier)\n\n  const { tryExtensions, esExtensions, esExtensionDefault, ensureFileExists } = options\n\n  const targetModule = evaluateTargetModule({\n    moduleSpecifier: originalModuleSpecifier,\n    filenameDirectory: fileDir,\n    filenameExtension: fileExt,\n    currentModuleExtension,\n    isDirectory,\n    tryExtensions,\n    esExtensions,\n    esExtensionDefault,\n    ensureFileExists,\n  })\n\n  if (targetModule === false) {\n    return null\n  }\n\n  return targetModule\n}\n\nfunction isLocalDirectory(absoluteDirectory: string) {\n  return existsSync(absoluteDirectory) && lstatSync(absoluteDirectory).isDirectory()\n}\n\nfunction evaluateTargetModule({\n  moduleSpecifier,\n  currentModuleExtension,\n  isDirectory,\n  filenameDirectory,\n  filenameExtension,\n  tryExtensions,\n  esExtensions,\n  esExtensionDefault,\n  ensureFileExists,\n}) {\n  if (currentModuleExtension && !esExtensions.includes(currentModuleExtension)) {\n    return false\n  }\n\n  const targetFile = resolve(filenameDirectory, moduleSpecifier)\n\n  if (ensureFileExists) {\n    for (const extension of tryExtensions) {\n      if (existsSync(targetFile + extension)) {\n        return moduleSpecifier + esExtensionDefault\n      }\n    }\n\n    // fallback to directory, so we find the non-dir first\n    if (\n      isDirectory &&\n      !existsSync(\n        resolve(\n          filenameDirectory,\n          currentModuleExtension ? moduleSpecifier : moduleSpecifier + esExtensionDefault\n        )\n      )\n    ) {\n      moduleSpecifier = `${moduleSpecifier}/index`\n    }\n  } else if (esExtensions.includes(filenameExtension)) {\n    return moduleSpecifier + esExtensionDefault\n  } else {\n    return moduleSpecifier + esExtensionDefault\n  }\n\n  return false\n}\n"
  ],
  "version": 3
}