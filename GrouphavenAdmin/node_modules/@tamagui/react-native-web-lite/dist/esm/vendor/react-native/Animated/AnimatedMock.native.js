import { AnimatedEvent, attachNativeEvent } from "./AnimatedEvent.native.js";
import AnimatedImplementation from "./AnimatedImplementation.native.js";
import createAnimatedComponent from "./createAnimatedComponent.native.js";
import AnimatedColor from "./nodes/AnimatedColor.native.js";
import AnimatedInterpolation from "./nodes/AnimatedInterpolation.native.js";
import AnimatedNode from "./nodes/AnimatedNode.native.js";
import AnimatedValue from "./nodes/AnimatedValue.native.js";
import AnimatedValueXY from "./nodes/AnimatedValueXY.native.js";
var inAnimationCallback = !1;
function mockAnimationStart(start) {
  return function (callback) {
    var guardedCallback = callback == null ? callback : function () {
      if (inAnimationCallback) {
        console.warn("Ignoring recursive animation callback when running mock animations");
        return;
      }
      inAnimationCallback = !0;
      try {
        callback(...arguments);
      } finally {
        inAnimationCallback = !1;
      }
    };
    start(guardedCallback);
  };
}
var emptyAnimation = {
    start: function () {},
    stop: function () {},
    reset: function () {},
    _startNativeLoop: function () {},
    _isUsingNativeDriver: function () {
      return !1;
    }
  },
  mockCompositeAnimation = function (animations) {
    return {
      ...emptyAnimation,
      start: mockAnimationStart(function (callback) {
        animations.forEach(function (animation) {
          return animation.start();
        }), callback?.({
          finished: !0
        });
      })
    };
  },
  spring = function (value, config) {
    var anyValue = value;
    return {
      ...emptyAnimation,
      start: mockAnimationStart(function (callback) {
        anyValue.setValue(config.toValue), callback?.({
          finished: !0
        });
      })
    };
  },
  timing = function (value, config) {
    var anyValue = value;
    return {
      ...emptyAnimation,
      start: mockAnimationStart(function (callback) {
        anyValue.setValue(config.toValue), callback?.({
          finished: !0
        });
      })
    };
  },
  decay = function (value, config) {
    return emptyAnimation;
  },
  sequence = function (animations) {
    return mockCompositeAnimation(animations);
  },
  parallel = function (animations, config) {
    return mockCompositeAnimation(animations);
  },
  delay = function (time) {
    return emptyAnimation;
  },
  stagger = function (time, animations) {
    return mockCompositeAnimation(animations);
  },
  loop = function (animation, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? -1 : _ref$iterations;
    return emptyAnimation;
  },
  AnimatedMock_default = {
    Value: AnimatedValue,
    ValueXY: AnimatedValueXY,
    Color: AnimatedColor,
    Interpolation: AnimatedInterpolation,
    Node: AnimatedNode,
    decay,
    timing,
    spring,
    add: AnimatedImplementation.add,
    subtract: AnimatedImplementation.subtract,
    divide: AnimatedImplementation.divide,
    multiply: AnimatedImplementation.multiply,
    modulo: AnimatedImplementation.modulo,
    diffClamp: AnimatedImplementation.diffClamp,
    delay,
    sequence,
    parallel,
    stagger,
    loop,
    event: AnimatedImplementation.event,
    createAnimatedComponent,
    attachNativeEvent,
    forkEvent: AnimatedImplementation.forkEvent,
    unforkEvent: AnimatedImplementation.unforkEvent,
    Event: AnimatedEvent
  };
export { AnimatedMock_default as default };
//# sourceMappingURL=AnimatedMock.native.js.map
